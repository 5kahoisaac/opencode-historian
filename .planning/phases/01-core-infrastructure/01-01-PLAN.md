---
phase: 01-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/config/schema.ts
  - src/config/loader.ts
  - src/config/constants.ts
  - src/config/index.ts
autonomous: true

must_haves:
  truths:
    - Plugin configuration loads from user-level config path
    - Project-level config overrides user-level config
    - Config schema validates all required fields with Zod
    - JSONC comments are properly stripped before parsing
  artifacts:
    - path: src/config/schema.ts
      provides: Zod schemas for PluginConfig and MemoryType
      exports:
        - PluginConfigSchema
        - MemoryTypeSchema
        - PluginConfig type
        - MemoryType type
    - path: src/config/loader.ts
      provides: Hierarchical config loading (user → project)
      exports:
        - loadPluginConfig
        - findConfigPath
    - path: src/config/constants.ts
      provides: Default values and path constants
      exports:
        - DEFAULT_CONFIG
        - getUserConfigPath
        - getProjectConfigPath
    - path: src/config/index.ts
      provides: Config module exports
      exports:
        - All config types and functions
  key_links:
    - from: src/config/loader.ts
      to: src/config/schema.ts
      via: Zod parse
      pattern: PluginConfigSchema.parse
    - from: src/config/loader.ts
      to: src/config/constants.ts
      via: Import defaults and paths
      pattern: DEFAULT_CONFIG
---

<objective>
Establish the configuration infrastructure with Zod schemas, hierarchical loading (user-level → project-level), and JSONC support. This provides the foundation for all other components.

Purpose: Configuration drives agent behavior, storage paths, and plugin settings. Without robust config loading, nothing else works reliably.
Output: Complete config module with type-safe validation.
</objective>

<execution_context>
@./.opencode/agents/gsd-executor.md
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies</name>
  <files>package.json</files>
  <action>
    Add missing dependencies to package.json:
    - gray-matter (^4.0+) for YAML frontmatter parsing
    - strip-json-comments (latest) for JSONC support
    
    Run `bun install` after updating package.json to install dependencies.
    
    These are essential for config parsing (strip-json-comments) and memory file handling (gray-matter) in subsequent plans.
  </action>
  <verify>bun install completes without errors; node_modules contains gray-matter and strip-json-comments</verify>
  <done>Dependencies installed and ready to import</done>
</task>

<task type="auto">
  <name>Task 2: Create Zod config schemas</name>
  <files>src/config/schema.ts</files>
  <action>
    Create src/config/schema.ts with Zod schemas per CONTEXT.md:
    
    1. MemoryTypeSchema with:
       - name: z.string().min(1)
       - description: z.string()
       - template: z.string().optional()
    
    2. PluginConfigSchema with:
       - model: z.string().default('opencode/kimi-k2.5-free')
       - temperature: z.number().min(0).max(2).default(0.3)
       - appendPrompt: z.string().optional()
       - externalPaths: z.array(z.string()).optional()
       - memoryTypes: z.array(MemoryTypeSchema).optional()
       - autoCompound: z.boolean().default(true)  // CONF-03
       - logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info')
       - debug: z.boolean().default(false)
    
    3. Export inferred types: PluginConfig and MemoryType
    
    Follow the oh-my-opencode-slim pattern. All fields must match CONTEXT.md exactly.
  </action>
  <verify>TypeScript typecheck passes: bun run typecheck</verify>
  <done>Zod schemas defined with correct types, defaults, and validation</done>
</task>

<task type="auto">
  <name>Task 3: Create config constants</name>
  <files>src/config/constants.ts</files>
  <action>
    Create src/config/constants.ts with:
    
    1. DEFAULT_CONFIG object with all default values from schema
    
    2. Path helper functions:
       - getUserConfigDir(): returns XDG_CONFIG_HOME or ~/.config
       - getUserConfigPath(): returns path to ~/.config/opencode/opencode-historian
       - getProjectConfigPath(projectRoot): returns path to .opencode/opencode-historian
       - getGlobalMemoryPath(): returns ~/.config/opencode/mnemonics  // CORE-02
    
    3. PROJECT_MEMORY_DIR constant = '.mnemonics'  // CORE-03
    
    Use node:path and node:os for cross-platform compatibility. Follow RESEARCH.md Pattern 2 for path resolution.
  </action>
  <verify>TypeScript typecheck passes; constants export correctly</verify>
  <done>All path constants defined respecting XDG_CONFIG_HOME</done>
</task>

<task type="auto">
  <name>Task 4: Implement hierarchical config loader</name>
  <files>src/config/loader.ts</files>
  <action>
    Create src/config/loader.ts implementing hierarchical config loading per RESEARCH.md Pattern 2:
    
    1. findConfigPath(basePath: string): string | null
       - Check for .jsonc first, then .json
       - Return null if neither exists
    
    2. loadConfigFromPath(path: string): PluginConfig | null
       - Read file with fs.readFileSync
       - Strip JSONC comments using strip-json-comments
       - Parse JSON
       - Validate with PluginConfigSchema.parse
       - Return null on ENOENT, warn on other errors
    
    3. loadPluginConfig(directory: string): PluginConfig
       - Load user-level config from ~/.config/opencode/opencode-historian.{json,jsonc}
       - Load project-level config from .opencode/opencode-historian.{json,jsonc}
       - Merge with project overriding user (deep merge for memoryTypes)
       - Return merged config
    
    CONF-01, CONF-03, CONF-04: Schema supports JSON, autoCompound default true, memoryTypes array.
  </action>
  <verify>TypeScript typecheck passes; loader imports schema and constants correctly</verify>
  <done>Hierarchical config loading implemented with proper merging</done>
</task>

<task type="auto">
  <name>Task 5: Create config module index</name>
  <files>src/config/index.ts</files>
  <action>
    Create src/config/index.ts as the public API for the config module:
    
    1. Re-export all from schema.ts:
       - PluginConfigSchema, MemoryTypeSchema
       - PluginConfig type, MemoryType type
    
    2. Re-export all from loader.ts:
       - loadPluginConfig, findConfigPath, loadConfigFromPath
    
    3. Re-export all from constants.ts:
       - DEFAULT_CONFIG
       - getUserConfigPath, getProjectConfigPath, getGlobalMemoryPath
       - PROJECT_MEMORY_DIR
    
    This provides a single import point: import { ... } from './config'
  </action>
  <verify>TypeScript typecheck passes; all exports are accessible</verify>
  <done>Config module fully exported and ready for use</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `bun run typecheck` - must pass with no errors
2. Verify imports work: create a test import in a temp file importing from './config'
3. Check config loading logic handles missing files gracefully (returns defaults)
4. Verify JSONC comments are stripped before parsing (test with a .jsonc file)
</verification>

<success_criteria>
- Zod schemas defined for PluginConfig and MemoryType
- Hierarchical config loading works (user → project merge)
- JSONC support implemented via strip-json-comments
- All config constants exported (paths, defaults)
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-01-SUMMARY.md`
</output>
