---
phase: 01-core-infrastructure
plan: 06
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-02
  - 01-03
  - 01-04
  - 01-05
files_modified:
  - src/index.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - Plugin exports full plugin object per CONTEXT.md
    - Tool permissions restrict memory tools to historian only
    - Config hook modifies OpenCode configuration
    - Event hook has minimal stub implementation
    - CLI entry point exists for install commands
  artifacts:
    - path: src/index.ts
      provides: Plugin entry point
      exports: [default plugin function]
      min_lines: 80
    - path: src/cli/index.ts
      provides: CLI entry point
      exports: [main CLI function]
  key_links:
    - from: src/index.ts
      to: config hook
      via: permission rules for memory_* tools
      pattern: permission['memory_*']
    - from: src/index.ts
      to: src/agents/historian.ts
      via: Agent registration
    - from: src/index.ts
      to: src/tools/index.ts
      via: Tool registration
---

<objective>
Implement the main plugin entry point and CLI interface, integrating all components with proper tool permission restrictions.

Purpose: This is the integration layer that wires everything together and exports the complete plugin object for OpenCode.
Output: Working plugin entry point with full MCP registration and CLI.
</objective>

<execution_context>
@./.opencode/agents/gsd-executor.md
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plugin entry point</name>
  <files>src/index.ts</files>
  <action>
    Create src/index.ts as the plugin entry point per RESEARCH.md Pattern 1:
    
    1. Import dependencies from @opencode-ai/plugin
    2. Import config loader from ./config
    3. Import createHistorianAgent from ./agents
    4. Import createMemoryTools from ./tools
    
    5. Export default async function OpencodeHistorian(ctx):
       - Load config: const config = loadPluginConfig(ctx.directory)
       - Create historian agent
       - Create memory tools
       
       Return plugin object with:
       - name: 'opencode-historian'
       - agent: { historian: createHistorianAgent(config) }
       - tool: createMemoryTools(config, ctx.directory)
       - config: async (opencodeConfig) => {
           // Set default agent
           // Configure tool permissions: ONLY historian gets memory_* tools
           // Deny memory_* to all other agents
         }
       - event: async (input) => {
           // Minimal stub for Phase 1
           // Log event type if debug enabled
         }
    
    Tool permissions must be agent-scoped per CONTEXT.md.
  </action>
  <verify>TypeScript typecheck passes; plugin exports correct shape</verify>
  <done>Plugin entry point exports full plugin object</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI entry point</name>
  <files>src/cli/index.ts</files>
  <action>
    Create src/cli/index.ts for CLI commands:
    
    1. Parse command line arguments
    2. Support commands:
       - install: Set up plugin configuration
       - doctor: Verify installation and dependencies
       
    3. Install command:
       - Create user config dir if needed
       - Create default config file
       - Set up global memory directory
       
    4. Doctor command:
       - Check qmd is installed
       - Check config files exist
       - Verify directory permissions
       - Report any issues
    
    STRC-03: cli/ â€” Install command and CLI interface.
  </action>
  <verify>TypeScript typecheck passes; CLI can be built</verify>
  <done>CLI entry point with install and doctor commands</done>
</task>

<task type="auto">
  <name>Task 3: Add types module</name>
  <files>src/types/index.ts</files>
  <action>
    Create src/types/index.ts for shared TypeScript interfaces:
    
    1. Re-export types from config module
    2. Re-export types from storage module
    3. Add any additional shared interfaces needed
    
    This centralizes type definitions for the plugin.
  </action>
  <verify>TypeScript typecheck passes</verify>
  <done>Types module created</done>
</task>

<task type="auto">
  <name>Task 4: Verify full build</name>
  <files>package.json</files>
  <action>
    Verify the complete plugin builds correctly:
    
    1. Run `bun run typecheck` - must pass with no errors
    2. Run `bun run build` - must complete successfully
    3. Verify dist/index.js exists
    4. Verify dist/cli/index.js exists
    
    Fix any TypeScript or build errors that arise.
  </action>
  <verify>bun run build completes without errors</verify>
  <done>Full plugin builds successfully</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `bun run typecheck` - must pass
2. Run `bun run build` - must create dist/
3. Verify plugin exports correct structure
4. Check tool permissions restrict memory_* to historian
</verification>

<success_criteria>
- Plugin exports full plugin object (STRC-01)
- Tool permissions restrict memory tools to historian (STRC-02)
- CLI entry point exists (STRC-03)
- Config hook modifies OpenCode config (STRC-04)
- Event hook has stub implementation
- Full build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-06-SUMMARY.md`
</output>
